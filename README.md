# Тестовое задание Mediasoft.team на Java EE
## Проект "Post REST Service"
### Разработчик - Колков Кирилл

****
```
Необходимо реализовать REST API, который позволяет отслеживать почтовые отправления.

В системе должны регистрироваться почтовые отправления — письма, посылки — их передвижение между почтовыми отделениями,
а также должна быть реализована возможность получения информации и всей истории передвижения конкретного почтового 
отправления.

Операции, которые должны быть реализованы:
- регистрация почтового отправления
- его прибытие в промежуточное почтовое отделение
- его убытие из почтового отделения
- его получение адресатом
- просмотр статуса и полной истории движения почтового отправления

Почтовое отправление определяется следующими свойствами:
- идентификатор
- тип(письмо,посылка,бандероль,открытка) 
- индекс получателя
- адрес получателя
- имя получателя

Почтовое отделение характеризуется следующими свойствами:
- индекс
- название 
- адрес

Сервис может быть реализован в виде JSON, либо XML-сервиса — на выбор.

Сервис может быть реализован при помощи стека Java EE, либо при помощи Spring.

Может использоваться любая СУБД для хранения данных.

Работа с данными должна происходить посредством ORM, может использоваться любая библиотека или API.

Приложение должно собираться при помощи Maven или Gradle.

Результатом сборки приложения должен быть war или ear архив, который может быть размещен на сервер приложений. 
Для отладки и демонстрации может использоваться любой сервер приложений.

К приложению должно прилагаться описание его API — структура запросов и ответов, список допустимых операций, 
можно это реализовать в виде проекта SoapUI.

```
****

# Настройки проекта
### Для запуска проекта необходимо:

1. Скачать исходный код сервиса [по ссылке](https://github.com/kkolkov/post.git) GitHub и открыть его в вашей среде разработки.
2. Добавить источник данных PostgreSQL. Настройки подключения к базе данных прописаны в файле application.properties. 
Пожалуйста, используйте их при настройке базы PostgreSQL.
3. Запустить приложение. Для проверки работы сервиса, рекомендуется начинать с тестов конечных точек (Endpoints). Все тесты доступны в классе *****EndpointsAvailabilityTest*****.
4. При возникновении ошибки *****invalid source release***** установите в настройках проекта SDK java version "18.0.2"
```
   spring.datasource.url=jdbc:postgresql://77.239.243.9:5432/mediasoft?currentSchema=post
   spring.datasource.username=postgres
   spring.datasource.password=NagioS
```

# Документация
Документация к сервису разработана на Swagger и доступна [по ссылке](https://app.swaggerhub.com/apis/kkolkov/post/1.0.0) SwaggerHub.

# Подробное описание "Post REST Service"
### На проекте взаимодействуют со следующими сущностями:

1. ****Dispatch**** - почтовое отправление, которое может быть типом ****DispatchType**** - письмо, посылка, бандероль или открытка.
2. ****Customer**** - владелец отправления, клиент почтового отделения.
3. ****Direction**** - направление посылки, конечный адрес.
4. ****Office**** - название офиса, в котором пользователь зарегистрировал отправление.
5. ****Address**** - адрес офиса, в котором пользователь зарегистрировал отправление.
6. ****Status**** - текущее местонахождение отправления с полной историей и временем. Согласно условию задачи, 
отправление может иметь 4 типа статуса ****StatusType**** - зарегистрировано, прибыло, убыло, получено.
7. ****DispatchSticker**** - наклейка/распечатка, которую получит пользователь от сотрудника почты после регистрации отправления. 
\
На наклейке будет указано имя клиента, индекс и адрес, а также уникальный номер отправления ****id****, благодаря которому 
пользователь сможет уточнить текущий статус отправления.

### Между сущностями существуют следующие виды отношений:
1. Между сущностями ****Dispatch**** и ****Customer**** возникает отношение "многие к одному".\
   Между сущностями ****Customer**** и ****Direction**** "один к одному".\
Известно, что пользователь может отправить одну или несколько посылок на один конкретный адрес. При необходимости 
отправки на другой адрес, создается новое отправление с новой наклейкой (см. выше) и новым id для
просмотра ее статуса.
2. Между сущностями ****Office**** и ****Address**** "один к одному".\
У каждого почтового отделения есть свой один единственный адрес.
3. Сущность ****Status**** связующая между ****Office**** и ****Dispatch****. Отношение между последними "многие ко многим".\
*для более подробного ознакомления, рекомендуется построить диаграмму визуализации связей базы данных.

### Про нормализацию таблиц и допущенные упрощения:
Все таблицы нормализованы.\
Тем не менее в финальной версии сервиса необходимо:
1. Заменить поля "address" в обеих таблицах на несколько полей "city", "street", "houseNumber", "apt", причем поле "apt" должно отсутствовать в таблице
****Address****, так как у почтового отделения обычно отсутствует _номер_ квартиры/офиса.
2. Заменить поле "name" на три поля "firstName", "lastName", "middleName".

### Как работает сервис?:
```
Важно! В программе работает генератор случайных почтовых офисов RandomPostOfficeGenerator. Когда регистрируется посылка, 
для отслеживания ее статуса необходимо добавить дополнительные поля (индекс, адрес и название офиса). Понятно, что оператору
нет смысла добавлять их вручную к каждой посылке. Ко всему прочему, адреса отделений и их индексы заранее хранятся в базе и 
очень редко меняются. Эти поля создаются автоматически в зависимости от принявшего отправление офиса.
То же самое касается промежуточного отделения - поступила полылка, отработали сканером на ее трекинг-номере, сканер дополнительно
добавил в базу поля с текущим адресом офиса. При отправлении посылки опять сканер. При получении, соответственно тоже он.

```
1. Клиент регистрирует посылку в любом удобном почтовом офисе. Регистрацию предоставляет ****RegistrationController**** по POST запросу на /register/new. 
После ввода данных получателя (его имени, индекса, адреса и типа посылки ****RegistrationDTO****), генерируется трекинг-номер или id отправления 
****DispatchSticker****, по которому получатель и отправитель могут отследить текущий статус отправления.
Пример запроса, его вывод и возможность протестировать новый запрос доступны по ссылке SwaggerHub в разделе "Документация".
2. При поступлении отправления в промежуточный офис работает сканер поступающих на отделение посылок. При сканировнии в базу добавляется id отправления,
адрес и индекс текущего офиса, а статус меняется на ****StatusType**** "прибыло".
3. При отправлении из офиса и получении посылки клиентом, алгоритм аналогичный пункту 2 данного блока.
4. Статус отправления предоставляет ****StatusController**** по POST запросу на /status/get/{id}. Выбор метода POST вместо GET связан с безопасностью.
Чтобы посмотреть текущий статус, клиенту необходимо заполнить поле, в которое необходимо ввести трекинг-номер или id, полученный им при регистрации.

```
Спасибо :)
```
